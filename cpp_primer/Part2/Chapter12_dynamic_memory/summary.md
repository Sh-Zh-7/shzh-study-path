# 第三章习题总结
1. 你要知道，比如访问空容器的首元素，也是一种“越界”的错误，只要检测是否大于size
2. 个人认为你在SafeFree的时候**没有必要判断**释放的指针是不是空指针，有两个方面的原因：
   1. 首先就算你传入的是空指针，你delete也可以正确执行（应该是不执行任何操作）
   2. 而且，你这样也无法解决多个指针指向同一个内存的问题。 
3. 正如我们普通的指针也要使用new分配地址一样，shared_ptr也要通过make_shared来获取相关动态内存的地址。（同时你要注意到make_shared也是要**提供类型参数**的）
4. 注意constexpr只能用于char数组，而不能用于string类型。
5. 虽然自己在看的时候反复强调，但是在写的时候仍然会出现内存泄漏的毛病。
6. 我感觉allocator可以委以大用！其存在的意义就在于**将内存的分配和对象的构造分离开来了**（当然了这样也使得**销毁的时候，需要析构对象+释放内存**），附使用方法：
   1. 先声明一个allocator对象（可以视为是某种器之类的东西），用其分配**裸内存**，返回值是一个const的指针（返回**常量的首地址**，如同我们认识的数组一样）。
   2. 你要知道我们表达一个数组至少需要两个量，于是我们需要再次声明一个非常量的指针，用来指向该数组中的其它元素。
   3. 构造对象的时候，使用construct方法。**利用非常量指针不断构造对象（最后该指针指向的是数组的末端位置）**
   4. 使用的时候，**利用刚才的const指针，当作一个普通的数组来使用**。
   5. 销毁的时候，利用两个指针**destroy对象，再deallocate释放内存**。
7. ps不允许像cmd一样输入可执行文件名就执行文件，这是因为可能会产生冲突——比如再ps中输入main，就会跳出控制鼠标的界面；如果你写了一个可执行文件main，那就会产生冲突；
8. 如果成员函数是const的，在函数体中使用函数时，**传引用要万分小心**——小心你的那个函数修改了你那个const
9. 学习GDB的必要性——不然像这种配置只能编译一个源文件，局限性非常大。
10. 注意你文件的路径是定位在**你编译器执行的位置**。