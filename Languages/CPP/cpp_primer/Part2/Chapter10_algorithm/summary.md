## 第10章习题总结
1. 泛型算法一般都是传入迭代器，然后返回一个迭代器。注意即便在传入参数的时候，我们依然可以传入const_iterator或者是iterator类型的参数。这时候的选择就可以体现我们的实力了。
2. 你要注意algorithem和numeric是两种完全不同的头文件，比如accmulate只定义在numeric中，而并不定义在algorithem中
3. 哪怕是inline函数，也是可以作为sort和stable_sort中所需要的谓词使用。
4. 定义的函数可以直接当作是函数使用。
5. **sort和partition**之间的区别就在于使用的是**一元谓词还是二元谓词**
6. 通过partition我们可以了解到还有把我们的**数据划分的这样一种操作**。
7. lambda满足了我之前小白时期对函数的一点不好的幻想——他要在}中最后一句已经加了;的前提下，再在}后面加一个;。也就是说，它有两个；，非常难受好吧。
8. 在lambda中其实你可以不指定函数的位置返回类型，**也就是说-> type这些都可以省略。这个就非常好!**
9. return -1和exit(EXIT_FAILURE)之间的差别：return是跳出当前函数，EXIT是直接退出当前的程序了。
10. 写了这么多system("pause>nul")，我总算有点明白它所代表的含义了——其它IDE给你在控制台暂停，是太为你找想了。其实你到最后真正发布程序的时候，return一下你的控制台就自动关闭了，所以system("pause")还是有它存在的意义的。
11. 输出参数存在的意义：如果仅仅是靠return返回值的话，有时候你要返回一个大一点的对象就很麻烦——函数体内要构造一个对象，同时return的时候还要拷贝构造一下（返回给调用点），给接受返回值的对象也还要使用赋值表达式（当然也有可能是拷贝构造函数）。而你使用输出参数的话就能很好地避开这一点。
12. 返回一个临时对象——显示使用构造函数。
13. 你要知道我们可以用两个迭代器来构造一个新的容器。但是不能通过=直接利用两个迭代器，还好我们有assign方法。
14. base方法返回的是当前逆向迭代器的后一个元素，这一点很符合STL的哲学，**但是有的时候我们真的需要这个元素的正向迭代器**，那我们就真的得用前置++返回前一个迭代器，再用distance了。
15. **迭代器转索引——distance函数；索引转迭代器——使用构造函数**。
16. 我好像明白点什么了：
    1.  很多容器只不过是一种数据结构，然而很多算法是独立于数据结构的。
    2.  预期每个容器都单独使用相同的算法，不如定义一群非成员函数，然后放在一个头文件内。
    3.  iterator为所有容器提供了一个接口，而且是功能强大的接口。这样我们再编写算法时就不需要考虑不同容器之间不同的特性了。
    4.  但是链表这个东西比较特殊，很多规则（比如迭代器的类别）对其根本不适用；所以要单独定义一套算法，放进容器本身——看上去增加了我们记忆的难度，因为我们不能用统一的算法来处理所有容器了，但是好在list和forward_list实现的算法更好。这点去了解下就知道了。